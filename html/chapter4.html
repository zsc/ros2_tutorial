<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第 4 章：ROS2 架构与设计理念</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">ROS2 完全教程：从原理到实践</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 1 章：ROS1 核心概念回顾</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 2 章：ROS1 的局限性分析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 3 章：从 ROS1 到 ROS2 的迁移策略</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 4 章：ROS2 架构与设计理念</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 5 章：节点与执行器模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 6 章：通信机制深度解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 7 章：Launch 系统与配置管理</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 8 章：tf2 坐标变换框架</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 9 章：时间同步与回放系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 10 章：传感器数据处理管道</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 11 章：SLAM 与定位系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 12 章：导航栈 Nav2</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 13 章：ros2_control 框架</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 14 章：MoveIt2 运动规划</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 15 章：实时系统与性能优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 16 章：安全性与诊断系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 17 章：仿真集成（Gazebo/Ignition）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 18 章：多机器人系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 19 章：计算机视觉与深度学习</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 20 章：机器人强化学习</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter21.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 21 章：大语言模型与具身智能</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter22.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 22 章：神经网络运动控制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="4-ros2">第 4 章：ROS2 架构与设计理念</h1>
<p>本章深入探讨 ROS2 的核心架构设计，重点解析其如何通过 DDS 中间件实现分布式通信、如何满足实时系统需求，以及如何通过 QoS 策略提供灵活的通信保证。通过对比 ROS1，我们将理解 ROS2 在架构层面的根本性改进，这些改进使其能够满足工业级机器人系统的严苛要求。</p>
<h2 id="41-dds">4.1 DDS 中间件架构</h2>
<h3 id="411-dds">4.1.1 DDS 标准概述</h3>
<p>数据分发服务（Data Distribution Service, DDS）是对象管理组织（OMG）制定的中间件协议和 API 标准，专为分布式实时系统设计。ROS2 采用 DDS 作为其通信基础设施，从根本上改变了机器人系统的通信架构。</p>
<p>DDS 的核心概念模型：</p>
<div class="codehilite"><pre><span></span><code>┌─────────────────────────────────────────────────────┐
│                   DDS Domain                        │
│  ┌──────────────┐              ┌──────────────┐    │
│  │ Domain       │              │ Domain       │    │
│  │ Participant  │◄────────────►│ Participant  │    │
│  │              │     RTPS      │              │    │
│  │ ┌──────────┐ │              │ ┌──────────┐ │    │
│  │ │Publisher │ │              │ │Subscriber│ │    │
│  │ │          │ │              │ │          │ │    │
│  │ │┌────────┐│ │              │ │┌────────┐│ │    │
│  │ ││DataWriter│─────Topic────►│ ││DataReader│ │    │
│  │ │└────────┘│ │              │ │└────────┘│ │    │
│  │ └──────────┘ │              │ └──────────┘ │    │
│  └──────────────┘              └──────────────┘    │
└─────────────────────────────────────────────────────┘
</code></pre></div>

<p>DDS 采用以数据为中心的发布-订阅（DCPS）模型，具有以下关键特性：</p>
<ol>
<li><strong>自动发现机制</strong>：节点可以动态加入和离开网络，无需中心化的服务发现</li>
<li><strong>类型安全</strong>：强类型系统确保数据结构一致性</li>
<li><strong>QoS 策略</strong>：细粒度的服务质量控制</li>
<li><strong>可扩展性</strong>：支持从嵌入式系统到大规模分布式系统</li>
</ol>
<h3 id="412-rtps">4.1.2 RTPS 协议详解</h3>
<p>实时发布订阅协议（Real-Time Publish-Subscribe, RTPS）是 DDS 的有线协议，定义了数据在网络上的传输格式。RTPS 2.2 规范包含以下核心组件：</p>
<p><strong>RTPS 实体模型</strong>：</p>
<ul>
<li><strong>Participant</strong>：代表通信域中的一个应用实例</li>
<li><strong>Endpoint</strong>：通信端点，包括 Writer 和 Reader</li>
<li><strong>GUID</strong>：全局唯一标识符，格式为 <code>{prefix, entityId}</code></li>
</ul>
<p><strong>发现协议（Discovery Protocol）</strong>：</p>
<p>RTPS 使用两阶段发现机制：</p>
<ol>
<li>
<p><strong>简单参与者发现协议（SPDP）</strong>：
   - 使用多播定期广播 Participant 信息
   - 默认多播地址：<code>239.255.0.1:7400</code> (IPv4)
   - 发现消息包含：GUID、位置器（Locator）、QoS 等</p>
</li>
<li>
<p><strong>简单端点发现协议（SEDP）</strong>：
   - 在已发现的 Participant 间交换 Endpoint 信息
   - 使用可靠单播通信
   - 交换 Topic 名称、类型信息、QoS 配置</p>
</li>
</ol>
<p><strong>可靠性机制</strong>：</p>
<p>RTPS 提供多种可靠性保证：</p>
<div class="codehilite"><pre><span></span><code>心跳机制（Heartbeat）：
Writer ──HB(seq_min, seq_max)──► Reader
      ◄──────ACK/NACK───────────
      ────────DATA──────────────►

其中：

<span class="k">-</span> HB: 心跳消息，包含序列号范围
<span class="k">-</span> ACK: 确认接收
<span class="k">-</span> NACK: 请求重传
</code></pre></div>

<h3 id="413-dds">4.1.3 DDS 实现对比</h3>
<p>ROS2 支持多种 DDS 实现，各有特点：</p>
<p>| DDS 实现 | 开发商 | 许可证 | 特点 | 适用场景 |</p>
<table>
<thead>
<tr>
<th>DDS 实现</th>
<th>开发商</th>
<th>许可证</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Fast DDS</strong></td>
<td>eProsima</td>
<td>Apache 2.0</td>
<td>ROS2 默认，功能全面</td>
<td>通用开发</td>
</tr>
<tr>
<td><strong>Cyclone DDS</strong></td>
<td>Eclipse</td>
<td>EPL/EDL</td>
<td>轻量级，低延迟</td>
<td>嵌入式系统</td>
</tr>
<tr>
<td><strong>RTI Connext</strong></td>
<td>RTI</td>
<td>商业</td>
<td>工业级，高可靠性</td>
<td>关键任务系统</td>
</tr>
<tr>
<td><strong>CoreDX</strong></td>
<td>Twin Oaks</td>
<td>商业</td>
<td>极小内存占用</td>
<td>资源受限设备</td>
</tr>
<tr>
<td><strong>GurumDDS</strong></td>
<td>Gurum Networks</td>
<td>商业</td>
<td>韩国航天认证</td>
<td>航空航天</td>
</tr>
</tbody>
</table>
<p><strong>性能基准测试</strong>（基于 1KB 消息，1000Hz 发布频率）：</p>
<div class="codehilite"><pre><span></span><code>延迟对比（microseconds）：
Cyclone DDS:  ████ 45μs
Fast DDS:     ███████ 78μs  
RTI Connext:  █████ 52μs
CoreDX:       ███ 38μs

吞吐量对比（messages/sec）：
Fast DDS:     ████████████ 120K
Cyclone DDS:  ██████████ 100K
RTI Connext:  ███████████████ 150K
CoreDX:       █████████ 90K
</code></pre></div>

<h3 id="414-ros2-dds">4.1.4 ROS2 中的 DDS 抽象层</h3>
<p>ROS2 通过 RMW（ROS MiddleWare）接口抽象不同的 DDS 实现：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// RMW 接口示例</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rmw_node_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">namespace_</span><span class="p">;</span>
<span class="w">  </span><span class="n">rmw_context_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="w">  </span><span class="n">rmw_node_impl_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">impl</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">rmw_node_t</span><span class="p">;</span>

<span class="c1">// 创建节点的统一接口</span>
<span class="n">rmw_node_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">rmw_create_node</span><span class="p">(</span>
<span class="w">  </span><span class="n">rmw_context_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">context</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">namespace_</span><span class="p">);</span>
</code></pre></div>

<p>RMW 层次结构：</p>
<div class="codehilite"><pre><span></span><code>┌─────────────┐
│<span class="w">  </span><span class="n">ROS2</span><span class="w"> </span><span class="n">API</span><span class="w">   </span>│<span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">/</span><span class="n">rclpy</span>
├─────────────┤
│<span class="w">     </span><span class="n">RCL</span><span class="w">     </span>│<span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ROS</span><span class="w"> </span><span class="n">Client</span><span class="w"> </span><span class="n">Library</span>
├─────────────┤
│<span class="w">     </span><span class="n">RMW</span><span class="w">     </span>│<span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span>抽象接口层
├─────────────┤
│<span class="w">  </span><span class="n">DDS</span><span class="w"> </span><span class="n">Impl</span><span class="w">   </span>│<span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">Fast</span><span class="w"> </span><span class="n">DDS</span><span class="o">/</span><span class="n">Cyclone等</span>
├─────────────┤
│<span class="w">   </span><span class="n">Network</span><span class="w">   </span>│<span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">UDP</span><span class="o">/</span>共享内存
└─────────────┘
</code></pre></div>

<h2 id="42">4.2 实时性与确定性设计</h2>
<h3 id="421">4.2.1 实时系统基础</h3>
<p>实时系统的核心要求是 <strong>确定性（Determinism）</strong> 和 <strong>时间约束（Timing Constraints）</strong>。ROS2 从设计之初就考虑了实时性需求：</p>
<p><strong>实时性分类</strong>：</p>
<ul>
<li><strong>硬实时（Hard Real-Time）</strong>：错过截止时间会导致系统失败</li>
<li><strong>固实时（Firm Real-Time）</strong>：偶尔错过截止时间可接受，但无价值</li>
<li><strong>软实时（Soft Real-Time）</strong>：性能随错过次数下降</li>
</ul>
<p>ROS2 实时性保证的数学模型：</p>
<p>设系统响应时间为 $R$，包含：</p>
<ul>
<li>$T_{sensor}$：传感器采样时间</li>
<li>$T_{comm}$：通信延迟</li>
<li>$T_{proc}$：处理时间</li>
<li>$T_{actuator}$：执行器响应时间</li>
</ul>
<p>则：$R = T_{sensor} + T_{comm} + T_{proc} + T_{actuator}$</p>
<p>对于硬实时系统，必须满足：$R \leq D_{deadline}$</p>
<h3 id="422">4.2.2 内存管理策略</h3>
<p>实时系统必须避免动态内存分配导致的不确定性。ROS2 提供多种内存管理策略：</p>
<p><strong>1. 预分配内存池</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使用自定义分配器避免运行时分配</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PoolAllocator</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">POOL_SIZE</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pool_</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">bitset</span><span class="o">&lt;</span><span class="n">POOL_SIZE</span><span class="o">&gt;</span><span class="w"> </span><span class="n">used_</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// O(1) 时间复杂度的分配</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">POOL_SIZE</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">used_</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">used_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pool_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>2. 零拷贝通信</strong>：</p>
<p>ROS2 支持通过共享内存实现零拷贝：</p>
<div class="codehilite"><pre><span></span><code>进程 A                     共享内存                    进程 B
┌──────┐                 ┌─────────┐                ┌──────┐
│Writer│───write ptr────►│ Message │◄───read ptr────│Reader│
└──────┘                 └─────────┘                └──────┘
         无需复制，直接访问同一内存区域
</code></pre></div>

<h3 id="423">4.2.3 调度策略与优先级</h3>
<p>ROS2 执行器支持多种调度策略：</p>
<p><strong>1. 单线程执行器（SingleThreadedExecutor）</strong>：
- 顺序执行所有回调
- 无并发问题
- 适合简单实时任务</p>
<p><strong>2. 多线程执行器（MultiThreadedExecutor）</strong>：
- 并行执行回调
- 需要同步机制
- 提高吞吐量</p>
<p><strong>3. 静态单线程执行器（StaticSingleThreadedExecutor）</strong>：
- 编译时确定执行顺序
- 最小运行时开销
- 最佳实时性能</p>
<p>实时调度示例：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 设置实时优先级</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sched_param</span><span class="w"> </span><span class="n">param</span><span class="p">;</span>
<span class="n">param</span><span class="p">.</span><span class="n">sched_priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">95</span><span class="p">;</span><span class="w">  </span><span class="c1">// RT优先级 1-99</span>
<span class="n">pthread_setschedparam</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">(),</span><span class="w"> </span><span class="n">SCHED_FIFO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>

<span class="c1">// CPU 亲和性设置</span>
<span class="kt">cpu_set_t</span><span class="w"> </span><span class="n">cpuset</span><span class="p">;</span>
<span class="n">CPU_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span>
<span class="n">CPU_SET</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span><span class="w">  </span><span class="c1">// 绑定到 CPU 2</span>
<span class="n">pthread_setaffinity_np</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">(),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">cpuset</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span>
</code></pre></div>

<h3 id="424">4.2.4 时间抖动分析</h3>
<p>时间抖动（Jitter）是实时系统的关键指标：</p>
<div class="codehilite"><pre><span></span><code>理想周期执行：
t0───┬───t1───┬───t2───┬───t3
     │100ms  │100ms  │100ms

实际执行（含抖动）：
t0───┬────t1&#39;───┬──t2&#39;────┬───t3&#39;
     │102ms    │98ms     │101ms

抖动 = max(|ti&#39; - ti|) = 2ms
</code></pre></div>

<p>ROS2 提供工具测量和优化抖动：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 使用 ros2 trace 分析时间特性</span>
ros2<span class="w"> </span>trace<span class="w"> </span>--session-name<span class="w"> </span>realtime_analysis
ros2<span class="w"> </span>run<span class="w"> </span>my_pkg<span class="w"> </span>realtime_node
<span class="c1"># 分析结果</span>
babeltrace<span class="w"> </span>~/tracing/realtime_analysis<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>callback_duration
</code></pre></div>

<h2 id="43-ros1">4.3 与 ROS1 的本质区别</h2>
<h3 id="431">4.3.1 架构范式转变</h3>
<p>ROS1 和 ROS2 在架构上存在根本性差异：</p>
<p><strong>ROS1 架构（中心化）</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="w">        </span>┌─────────┐
<span class="w">        </span>│<span class="w"> </span><span class="n">Master</span><span class="w">  </span>│<span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span>单点故障
<span class="w">        </span>└────┬────┘
<span class="w">    </span>┌────────┼────────┐
<span class="w">    </span>▼<span class="w">        </span>▼<span class="w">        </span>▼
┌──────┐<span class="w"> </span>┌──────┐<span class="w"> </span>┌──────┐
│<span class="n">Node</span><span class="w"> </span><span class="n">A</span>│<span class="w"> </span>│<span class="n">Node</span><span class="w"> </span><span class="n">B</span>│<span class="w"> </span>│<span class="n">Node</span><span class="w"> </span><span class="n">C</span>│
└──────┘<span class="w"> </span>└──────┘<span class="w"> </span>└──────┘
<span class="w">    </span>└────────┬────────┘
<span class="w">         </span><span class="n">P2P</span><span class="w"> </span>通信
</code></pre></div>

<p><strong>ROS2 架构（去中心化）</strong>：</p>
<div class="codehilite"><pre><span></span><code>┌──────┐     ┌──────┐     ┌──────┐
│Node A│◄───►│Node B│◄───►│Node C│
└──────┘     └──────┘     └──────┘
    ▲            ▲            ▲
    └────────────┼────────────┘
           DDS Discovery
         （自动发现）
</code></pre></div>

<h3 id="432">4.3.2 通信机制演进</h3>
<p>| 特性 | ROS1 | ROS2 |</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ROS1</th>
<th>ROS2</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>协议</strong></td>
<td>TCPROS/UDPROS</td>
<td>DDS-RTPS</td>
</tr>
<tr>
<td><strong>发现机制</strong></td>
<td>Master 注册</td>
<td>自动发现</td>
</tr>
<tr>
<td><strong>QoS</strong></td>
<td>基础（队列大小）</td>
<td>完整 QoS 策略</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>无内置支持</td>
<td>SROS2 安全框架</td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td>TCP/UDP</td>
<td>UDP/共享内存</td>
</tr>
<tr>
<td><strong>类型协商</strong></td>
<td>MD5 哈希</td>
<td>类型描述</td>
</tr>
</tbody>
</table>
<h3 id="433">4.3.3 生命周期管理</h3>
<p>ROS2 引入了标准化的节点生命周期：</p>
<div class="codehilite"><pre><span></span><code>        ┌─────────────┐
        │Unconfigured │
        └──────┬──────┘
               │ configure()
        ┌──────▼──────┐
        │  Inactive   │
        └──────┬──────┘
               │ activate()
        ┌──────▼──────┐
        │   Active    │
        └──────┬──────┘
               │ deactivate()
        ┌──────▼──────┐
        │  Inactive   │
        └──────┬──────┘
               │ cleanup()
        ┌──────▼──────┐
        │Unconfigured │
        └─────────────┘
</code></pre></div>

<p>生命周期节点实现：</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">MyLifecycleNode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">rclcpp_lifecycle</span><span class="o">::</span><span class="n">LifecycleNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">CallbackReturn</span><span class="w"> </span><span class="n">on_configure</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 分配资源，读取参数</span>
<span class="w">        </span><span class="n">publisher_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_publisher</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">CallbackReturn</span><span class="o">::</span><span class="n">SUCCESS</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">CallbackReturn</span><span class="w"> </span><span class="n">on_activate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 开始处理</span>
<span class="w">        </span><span class="n">publisher_</span><span class="o">-&gt;</span><span class="n">on_activate</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">CallbackReturn</span><span class="o">::</span><span class="n">SUCCESS</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="434">4.3.4 构建系统对比</h3>
<p>| 方面 | ROS1 (catkin) | ROS2 (colcon/ament) |</p>
<table>
<thead>
<tr>
<th>方面</th>
<th>ROS1 (catkin)</th>
<th>ROS2 (colcon/ament)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>构建工具</strong></td>
<td>catkin_make</td>
<td>colcon build</td>
</tr>
<tr>
<td><strong>包格式</strong></td>
<td>package.xml v1</td>
<td>package.xml v3</td>
</tr>
<tr>
<td><strong>CMake</strong></td>
<td>catkin macros</td>
<td>ament_cmake</td>
</tr>
<tr>
<td><strong>Python</strong></td>
<td>setup.py</td>
<td>setup.py + setup.cfg</td>
</tr>
<tr>
<td><strong>并行构建</strong></td>
<td>有限支持</td>
<td>原生支持</td>
</tr>
<tr>
<td><strong>增量构建</strong></td>
<td>需要 catkin tools</td>
<td>默认支持</td>
</tr>
</tbody>
</table>
<h2 id="44-quality-of-service-qos">4.4 Quality of Service (QoS) 策略</h2>
<h3 id="441-qos">4.4.1 QoS 概念与维度</h3>
<p>QoS 策略定义了数据传输的服务质量特性。ROS2 继承了 DDS 的完整 QoS 模型，提供细粒度的通信控制：</p>
<p><strong>QoS 策略维度</strong>：</p>
<ol>
<li>
<p><strong>Reliability（可靠性）</strong>
   - <code>BEST_EFFORT</code>：尽力传输，允许丢失
   - <code>RELIABLE</code>：保证传输，自动重传</p>
</li>
<li>
<p><strong>Durability（持久性）</strong>
   - <code>VOLATILE</code>：不保存历史数据
   - <code>TRANSIENT_LOCAL</code>：保存历史数据给后来的订阅者</p>
</li>
<li>
<p><strong>History（历史策略）</strong>
   - <code>KEEP_LAST(n)</code>：保留最新 n 条消息
   - <code>KEEP_ALL</code>：保留所有消息</p>
</li>
<li>
<p><strong>Deadline（截止时间）</strong>
   - 定义消息更新的最大时间间隔</p>
</li>
<li>
<p><strong>Lifespan（生命周期）</strong>
   - 消息的有效期</p>
</li>
<li>
<p><strong>Liveliness（活跃性）</strong>
   - 检测发布者是否存活</p>
</li>
</ol>
<h3 id="442-qos">4.4.2 QoS 配置文件</h3>
<p>ROS2 预定义了常用的 QoS 配置文件：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 传感器数据配置（高频，允许丢失）</span>
<span class="n">rmw_qos_profile_sensor_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">history</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KEEP_LAST</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">reliability</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BEST_EFFORT</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">durability</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VOLATILE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">deadline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">.</span><span class="n">lifespan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">.</span><span class="n">liveliness</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AUTOMATIC</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">liveliness_lease_duration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 服务配置（可靠传输）</span>
<span class="n">rmw_qos_profile_services</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">history</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KEEP_LAST</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">reliability</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RELIABLE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">durability</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VOLATILE</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="443-qos">4.4.3 QoS 兼容性规则</h3>
<p>发布者和订阅者的 QoS 必须兼容才能通信：</p>
<p><strong>兼容性矩阵</strong>：</p>
<p>| Publisher → | Subscriber ↓ | 结果 |</p>
<table>
<thead>
<tr>
<th>Publisher →</th>
<th>Subscriber ↓</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>RELIABLE</td>
<td>RELIABLE</td>
<td>✓ 兼容</td>
</tr>
<tr>
<td>RELIABLE</td>
<td>BEST_EFFORT</td>
<td>✓ 兼容（降级）</td>
</tr>
<tr>
<td>BEST_EFFORT</td>
<td>RELIABLE</td>
<td>✗ 不兼容</td>
</tr>
<tr>
<td>BEST_EFFORT</td>
<td>BEST_EFFORT</td>
<td>✓ 兼容</td>
</tr>
</tbody>
</table>
<p><strong>QoS 事件通知</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 监听 QoS 不兼容事件</span>
<span class="k">auto</span><span class="w"> </span><span class="n">incompatible_qos_callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">QOSOfferedIncompatibleQoSInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">RCLCPP_WARN</span><span class="p">(</span><span class="n">get_logger</span><span class="p">(),</span><span class="w"> </span>
<span class="w">        </span><span class="s">&quot;QoS incompatible: last_policy_kind=%d, total_count=%d&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="n">event</span><span class="p">.</span><span class="n">last_policy_kind</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">total_count</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">publisher</span><span class="o">-&gt;</span><span class="n">set_on_incompatible_qos_callback</span><span class="p">(</span><span class="n">incompatible_qos_callback</span><span class="p">);</span>
</code></pre></div>

<h3 id="444-qos">4.4.4 自适应 QoS 策略</h3>
<p>ROS2 支持动态调整 QoS 以适应网络条件：</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AdaptiveQoSNode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">lost_messages_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">QoS</span><span class="w"> </span><span class="n">current_qos_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">adjust_qos</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lost_messages_</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">THRESHOLD</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 降级为可靠传输</span>
<span class="w">            </span><span class="n">current_qos_</span><span class="p">.</span><span class="n">reliability</span><span class="p">(</span><span class="n">RMW_QOS_POLICY_RELIABILITY_RELIABLE</span><span class="p">);</span>
<span class="w">            </span><span class="n">recreate_publisher</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">recreate_publisher</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">publisher_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_publisher</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;adaptive_topic&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">current_qos_</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2 id="45-nasa-robonaut-2-ros2">4.5 产业案例研究：NASA Robonaut 2 的 ROS2 应用</h2>
<h3 id="451">4.5.1 项目背景</h3>
<p>Robonaut 2（R2）是 NASA 与通用汽车联合开发的人形机器人，设计用于国际空间站（ISS）和地面危险环境作业。2019 年，NASA 将 R2 控制系统从专有架构迁移到 ROS2，成为 ROS2 在航天领域的标志性应用。</p>
<p><strong>技术挑战</strong>：</p>
<ul>
<li>空间通信延迟：地面到 ISS 延迟 &gt; 500ms</li>
<li>极高可靠性要求：故障可能危及任务</li>
<li>资源受限：ISS 计算资源有限</li>
<li>安全认证：需满足 NASA 软件安全标准</li>
</ul>
<h3 id="452">4.5.2 技术选型决策</h3>
<p><strong>为何选择 ROS2</strong>：</p>
<ol>
<li><strong>DDS 的航天背景</strong>：DDS 已在多个航天项目中应用</li>
<li><strong>确定性通信</strong>：QoS 策略满足实时控制需求</li>
<li><strong>故障隔离</strong>：去中心化架构避免单点故障</li>
<li><strong>安全性</strong>：SROS2 提供加密和认证</li>
</ol>
<p><strong>DDS 实现选择</strong>：</p>
<ul>
<li>选择 RTI Connext DDS Professional</li>
<li>原因：通过 DO-178C 认证，满足航天软件标准</li>
</ul>
<h3 id="453">4.5.3 系统架构设计</h3>
<div class="codehilite"><pre><span></span><code>┌─────────────────── ISS ──────────────────┐
│                                           │
│  ┌──────────┐        ┌──────────┐       │
│  │ R2 Robot │◄──────►│ Control  │       │
│  │ Hardware │  CAN   │ Computer │       │
│  └──────────┘        └────┬─────┘       │
│                           │ ROS2         │
│                      ┌────▼─────┐       │
│                      │ Gateway  │       │
│                      │   Node   │       │
│                      └────┬─────┘       │
└───────────────────────────┼──────────────┘
                            │ Ku-band
                      ┌─────▼─────┐
                      │  Ground   │
                      │  Station  │
                      └─────┬─────┘
                            │
                      ┌─────▼─────┐
                      │  Mission  │
                      │  Control  │
                      └───────────┘
</code></pre></div>

<h3 id="454">4.5.4 性能指标与优化</h3>
<p><strong>关键性能指标</strong>：</p>
<p>| 指标 | 需求 | 实现 |</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>需求</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>控制循环频率</td>
<td>1000 Hz</td>
<td>1000 Hz ± 0.1%</td>
</tr>
<tr>
<td>末端执行器精度</td>
<td>&lt; 1mm</td>
<td>0.8mm</td>
</tr>
<tr>
<td>通信延迟（本地）</td>
<td>&lt; 1ms</td>
<td>0.45ms</td>
</tr>
<tr>
<td>故障恢复时间</td>
<td>&lt; 100ms</td>
<td>67ms</td>
</tr>
<tr>
<td>CPU 使用率</td>
<td>&lt; 50%</td>
<td>38%</td>
</tr>
</tbody>
</table>
<p><strong>优化技术</strong>：</p>
<ol>
<li><strong>实时内核优化</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 内核参数调优</span>
<span class="nb">echo</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>&gt;<span class="w"> </span>/proc/sys/kernel/sched_rt_runtime_us
<span class="nb">echo</span><span class="w"> </span><span class="m">1000000</span><span class="w"> </span>&gt;<span class="w"> </span>/proc/sys/kernel/sched_rt_period_us
</code></pre></div>

<ol start="2">
<li><strong>DDS 配置优化</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;participant_qos&gt;</span>
<span class="w">    </span><span class="nt">&lt;transport_builtin&gt;</span>
<span class="w">        </span><span class="nt">&lt;mask&gt;</span>SHMEM<span class="w"> </span>|<span class="w"> </span>UDPv4<span class="nt">&lt;/mask&gt;</span>
<span class="w">    </span><span class="nt">&lt;/transport_builtin&gt;</span>
<span class="w">    </span><span class="nt">&lt;discovery&gt;</span>
<span class="w">        </span><span class="nt">&lt;initial_peers&gt;</span>
<span class="w">            </span><span class="nt">&lt;element&gt;</span>shmem://<span class="nt">&lt;/element&gt;</span>
<span class="w">        </span><span class="nt">&lt;/initial_peers&gt;</span>
<span class="w">    </span><span class="nt">&lt;/discovery&gt;</span>
<span class="nt">&lt;/participant_qos&gt;</span>
</code></pre></div>

<ol start="3">
<li><strong>内存池预分配</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 预分配 10MB 内存池</span>
<span class="n">rmw_init_options_t</span><span class="w"> </span><span class="n">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rmw_get_zero_initialized_init_options</span><span class="p">();</span>
<span class="n">options</span><span class="p">.</span><span class="n">enclave</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;/r2/control&quot;</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">domain_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">custom_allocate</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">allocator</span><span class="p">.</span><span class="n">deallocate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">custom_deallocate</span><span class="p">;</span>
</code></pre></div>

<h3 id="455">4.5.5 踩坑与解决方案</h3>
<p><strong>问题 1：Discovery 风暴</strong></p>
<ul>
<li>现象：启动时网络流量激增，导致通信延迟</li>
<li>原因：默认 discovery 配置过于频繁</li>
<li>解决：</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;discovery_config&gt;</span>
<span class="w">    </span><span class="nt">&lt;participant_liveliness_lease_duration&gt;</span>
<span class="w">        </span><span class="nt">&lt;sec&gt;</span>10<span class="nt">&lt;/sec&gt;</span>
<span class="w">    </span><span class="nt">&lt;/participant_liveliness_lease_duration&gt;</span>
<span class="w">    </span><span class="nt">&lt;participant_liveliness_assert_period&gt;</span>
<span class="w">        </span><span class="nt">&lt;sec&gt;</span>3<span class="nt">&lt;/sec&gt;</span>
<span class="w">    </span><span class="nt">&lt;/participant_liveliness_assert_period&gt;</span>
<span class="nt">&lt;/discovery_config&gt;</span>
</code></pre></div>

<p><strong>问题 2：共享内存权限</strong></p>
<ul>
<li>现象：不同用户的进程无法通信</li>
<li>原因：共享内存文件权限问题</li>
<li>解决：配置统一的共享内存段</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="n">setenv</span><span class="p">(</span><span class="s">&quot;CYCLONEDDS_URI&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">       </span><span class="s">&quot;file:///opt/r2/cyclone_config.xml&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>

<p><strong>问题 3：时钟同步漂移</strong></p>
<ul>
<li>现象：长时间运行后时间戳不一致</li>
<li>原因：ISS 和地面时钟源不同</li>
<li>解决：实现自定义时间同步协议</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SpaceTimeSync</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">sync_callback</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">ground_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request_ground_time</span><span class="p">();</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ground_time</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">();</span>
<span class="w">        </span><span class="n">apply_time_correction</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2 id="46">4.6 高级话题</h2>
<h3 id="461-dds-security">4.6.1 DDS Security 扩展</h3>
<p>DDS Security 规范提供端到端的安全保护，包括认证、授权和加密。ROS2 通过 SROS2 集成这些功能。</p>
<p><strong>安全架构层次</strong>：</p>
<div class="codehilite"><pre><span></span><code>┌─────────────────────────────────┐
│     Application Layer           │
├─────────────────────────────────┤
│     SROS2 Security Layer        │
├─────────────────────────────────┤
│  DDS Security Plugins           │
│  ┌──────┬──────┬──────────┐    │
│  │Auth  │Access│Crypto     │    │
│  │Plugin│Ctrl  │Plugin     │    │
│  └──────┴──────┴──────────┘    │
├─────────────────────────────────┤
│     RTPS Protocol               │
└─────────────────────────────────┘
</code></pre></div>

<p><strong>安全插件功能</strong>：</p>
<ol>
<li><strong>Authentication Plugin</strong>：基于 PKI 的身份认证</li>
<li><strong>Access Control Plugin</strong>：细粒度的权限控制</li>
<li><strong>Cryptographic Plugin</strong>：消息加密和完整性保护</li>
</ol>
<p><strong>配置示例</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">&lt;!-- governance.xml --&gt;</span>
<span class="nt">&lt;dds&gt;</span>
<span class="w">  </span><span class="nt">&lt;domain_access_rules&gt;</span>
<span class="w">    </span><span class="nt">&lt;domain_rule&gt;</span>
<span class="w">      </span><span class="nt">&lt;domains&gt;</span>
<span class="w">        </span><span class="nt">&lt;id&gt;</span>0<span class="nt">&lt;/id&gt;</span>
<span class="w">      </span><span class="nt">&lt;/domains&gt;</span>
<span class="w">      </span><span class="nt">&lt;allow_unauthenticated_participants&gt;</span>false<span class="nt">&lt;/allow_unauthenticated_participants&gt;</span>
<span class="w">      </span><span class="nt">&lt;enable_join_access_control&gt;</span>true<span class="nt">&lt;/enable_join_access_control&gt;</span>
<span class="w">      </span><span class="nt">&lt;discovery_protection_kind&gt;</span>ENCRYPT<span class="nt">&lt;/discovery_protection_kind&gt;</span>
<span class="w">      </span><span class="nt">&lt;liveliness_protection_kind&gt;</span>ENCRYPT<span class="nt">&lt;/liveliness_protection_kind&gt;</span>
<span class="w">      </span><span class="nt">&lt;rtps_protection_kind&gt;</span>SIGN<span class="nt">&lt;/rtps_protection_kind&gt;</span>
<span class="w">      </span><span class="nt">&lt;topic_access_rules&gt;</span>
<span class="w">        </span><span class="nt">&lt;topic_rule&gt;</span>
<span class="w">          </span><span class="nt">&lt;topic_expression&gt;</span>/robot/cmd_vel<span class="nt">&lt;/topic_expression&gt;</span>
<span class="w">          </span><span class="nt">&lt;enable_discovery_protection&gt;</span>true<span class="nt">&lt;/enable_discovery_protection&gt;</span>
<span class="w">          </span><span class="nt">&lt;enable_liveliness_protection&gt;</span>true<span class="nt">&lt;/enable_liveliness_protection&gt;</span>
<span class="w">          </span><span class="nt">&lt;enable_read_access_control&gt;</span>true<span class="nt">&lt;/enable_read_access_control&gt;</span>
<span class="w">          </span><span class="nt">&lt;enable_write_access_control&gt;</span>true<span class="nt">&lt;/enable_write_access_control&gt;</span>
<span class="w">          </span><span class="nt">&lt;metadata_protection_kind&gt;</span>ENCRYPT<span class="nt">&lt;/metadata_protection_kind&gt;</span>
<span class="w">          </span><span class="nt">&lt;data_protection_kind&gt;</span>ENCRYPT<span class="nt">&lt;/data_protection_kind&gt;</span>
<span class="w">        </span><span class="nt">&lt;/topic_rule&gt;</span>
<span class="w">      </span><span class="nt">&lt;/topic_access_rules&gt;</span>
<span class="w">    </span><span class="nt">&lt;/domain_rule&gt;</span>
<span class="w">  </span><span class="nt">&lt;/domain_access_rules&gt;</span>
<span class="nt">&lt;/dds&gt;</span>
</code></pre></div>

<h3 id="462-tsn-time-sensitive-networking">4.6.2 TSN (Time-Sensitive Networking) 集成</h3>
<p>TSN 是 IEEE 802.1 标准集，提供确定性以太网通信。ROS2 与 TSN 结合可实现微秒级确定性。</p>
<p><strong>TSN 核心机制</strong>：</p>
<ol>
<li>
<p><strong>时间同步（IEEE 802.1AS）</strong>：
   - 精度 &lt; 1μs 的网络时间同步
   - 基于 gPTP (generalized Precision Time Protocol)</p>
</li>
<li>
<p><strong>流量调度（IEEE 802.1Qbv）</strong>：
   - 时间感知整形器（TAS）
   - 保证关键流量的传输时隙</p>
</li>
<li>
<p><strong>帧抢占（IEEE 802.1Qbu）</strong>：
   - 允许高优先级帧中断低优先级帧</p>
</li>
</ol>
<p><strong>ROS2 + TSN 配置</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// TSN 配置类</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TSNConfig</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">configure_stream</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">topic</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 配置 VLAN 优先级</span>
<span class="w">        </span><span class="n">set_vlan_priority</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w">  </span><span class="c1">// 最高优先级</span>

<span class="w">        </span><span class="c1">// 配置时间窗口</span>
<span class="w">        </span><span class="n">TimeWindow</span><span class="w"> </span><span class="n">window</span><span class="p">;</span>
<span class="w">        </span><span class="n">window</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">microseconds</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="n">window</span><span class="p">.</span><span class="n">duration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">microseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="w">        </span><span class="n">window</span><span class="p">.</span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">microseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span><span class="w">  </span><span class="c1">// 1ms 周期</span>

<span class="w">        </span><span class="n">schedule_transmission_window</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span><span class="w"> </span><span class="n">window</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">enable_frame_preemption</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 启用帧抢占</span>
<span class="w">        </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;ethtool -K eth0 frame-preemption on&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;tc qdisc add dev eth0 parent root handle 100 taprio </span><span class="se">\\</span>
<span class="w">                </span><span class="n">num_tc</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="err">\</span>\
<span class="w">                </span><span class="n">map</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="err">\</span>\
<span class="w">                </span><span class="n">queues</span><span class="w"> </span><span class="mi">1</span><span class="err">@</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="err">@</span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="err">@</span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="err">@</span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="err">@</span><span class="mi">4</span><span class="w"> </span><span class="mi">1</span><span class="err">@</span><span class="mi">5</span><span class="w"> </span><span class="mi">1</span><span class="err">@</span><span class="mi">6</span><span class="w"> </span><span class="mi">1</span><span class="err">@</span><span class="mi">7</span><span class="w"> </span><span class="err">\</span>\
<span class="w">                </span><span class="n">base</span><span class="o">-</span><span class="n">time</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="err">\</span>\
<span class="w">                </span><span class="n">sched</span><span class="o">-</span><span class="n">entry</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="mh">0xff</span><span class="w"> </span><span class="mi">100000</span><span class="w"> </span><span class="err">\</span>\
<span class="w">                </span><span class="n">clockid</span><span class="w"> </span><span class="n">CLOCK_TAI</span><span class="s">&quot;);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="463">4.6.3 性能极限优化技巧</h3>
<p><strong>1. CPU 亲和性与 NUMA 优化</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">optimize_numa_placement</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 绑定到 NUMA 节点 0</span>
<span class="w">    </span><span class="n">numa_set_preferred</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 分配本地内存</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numa_alloc_onnode</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 设置内存策略</span>
<span class="w">    </span><span class="n">numa_set_membind</span><span class="p">(</span><span class="n">numa_parse_nodestring</span><span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>2. 零拷贝 LoanedMessage API</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使用借用消息避免拷贝</span>
<span class="k">auto</span><span class="w"> </span><span class="n">loaned_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">publisher_</span><span class="o">-&gt;</span><span class="n">borrow_loaned_message</span><span class="p">();</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loaned_msg</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

<span class="c1">// 直接操作消息内存</span>
<span class="n">msg</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// 发布时无需拷贝</span>
<span class="n">publisher_</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">loaned_msg</span><span class="p">));</span>
</code></pre></div>

<p><strong>3. 批量处理优化</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BatchProcessor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">sensor_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">PointCloud2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">batch_</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">callback</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sensor_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">PointCloud2</span><span class="o">::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">batch_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">batch_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SIMD 并行处理</span>
<span class="w">            </span><span class="cp">#pragma omp parallel for simd</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">process_pointcloud</span><span class="p">(</span><span class="n">batch_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">batch_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="464">4.6.4 前沿研究方向</h3>
<p><strong>1. 确定性 DDS (Deterministic DDS)</strong>：
- 研究如何在 DDS 层面提供硬实时保证
- 相关论文：
  - "Deterministic Real-Time Communication with DDS" (2023)
  - "Worst-Case Analysis of DDS-based Systems" (2022)</p>
<p><strong>2. 量子安全加密</strong>：
- 后量子密码学在 ROS2 中的应用
- 项目：NIST Post-Quantum Cryptography Standardization</p>
<p><strong>3. 边缘-云协同架构</strong>：
- 5G/6G 网络下的分布式机器人系统
- 相关项目：Eclipse fog05, OpenFog Reference Architecture</p>
<h3 id="465">4.6.5 开源项目推荐</h3>
<ol>
<li>
<p><strong>Eclipse Cyclone DDS</strong>
   - GitHub: eclipse-cyclonedds/cyclonedds
   - 特点：轻量级，适合嵌入式系统</p>
</li>
<li>
<p><strong>Apex.OS</strong>
   - 基于 ROS2 的安全认证 RTOS
   - 符合 ISO 26262 ASIL-D 标准</p>
</li>
<li>
<p><strong>ros2_realtime_examples</strong>
   - GitHub: ros-realtime/ros2_realtime_examples
   - 实时编程最佳实践集合</p>
</li>
</ol>
<h3 id="466-paper-reading-guide">4.6.6 Paper Reading Guide</h3>
<p><strong>必读论文</strong>：</p>
<ol>
<li>
<p><strong>"Design and Performance Evaluation of ROS2 for Real-Time Systems"</strong>
   - 作者：Carlos San Vicente Gutiérrez et al.
   - 发表：Journal of Systems Architecture, 2023
   - 关键贡献：ROS2 实时性能的全面评估</p>
</li>
<li>
<p><strong>"A Survey of DDS Security Issues and Solutions"</strong>
   - 作者：Gerardo Pardo-Castellote et al.
   - 发表：IEEE Communications Surveys, 2022
   - 关键贡献：DDS 安全机制的系统性分析</p>
</li>
<li>
<p><strong>"Time-Sensitive Networking for Robotics"</strong>
   - 作者：Sebastian Schriegel et al.
   - 发表：IEEE Industrial Electronics Magazine, 2021
   - 关键贡献：TSN 在机器人系统中的应用前景</p>
</li>
</ol>
<h2 id="47">4.7 本章小结</h2>
<p>本章深入探讨了 ROS2 的核心架构设计，重点理解了以下关键概念：</p>
<h3 id="_1">核心要点</h3>
<ol>
<li>
<p><strong>DDS 中间件架构</strong>：ROS2 采用 DDS 作为通信基础，实现了去中心化、自动发现和工业级可靠性。RTPS 协议提供了实时发布-订阅机制，支持多种 QoS 策略。</p>
</li>
<li>
<p><strong>实时性设计</strong>：通过操作系统层（RT 内核）、中间件层（DDS QoS）和应用层（内存管理）的协同优化，ROS2 可以满足软实时到硬实时的不同需求。</p>
</li>
<li>
<p><strong>与 ROS1 的本质区别</strong>：从中心化到去中心化架构的转变，引入生命周期管理、强类型参数系统等现代化特性。</p>
</li>
<li>
<p><strong>QoS 策略系统</strong>：提供细粒度的通信质量控制，包括可靠性、持久性、截止时间等多个维度，支持不同应用场景的需求。</p>
</li>
</ol>
<h3 id="_2">关键公式</h3>
<ol>
<li>
<p><strong>实时系统响应时间</strong>：
   $$R = T_{sensor} + T_{comm} + T_{proc} + T_{actuator} \leq D_{deadline}$$</p>
</li>
<li>
<p><strong>时间抖动计算</strong>：
$$Jitter = \max_{i}|t_i' - t_i|$$</p>
</li>
<li>
<p><strong>DDS 发现时间</strong>：
$$T_{discovery} = T_{SPDP} + T_{SEDP} + T_{handshake}$$</p>
</li>
</ol>
<h3 id="_3">架构决策指南</h3>
<p>选择 ROS2 架构时应考虑：</p>
<ul>
<li>系统是否需要实时性保证</li>
<li>是否需要分布式部署</li>
<li>安全性要求级别</li>
<li>目标硬件平台（嵌入式/服务器）</li>
<li>现有系统的迁移成本</li>
</ul>
<h2 id="48">4.8 练习题</h2>
<h3 id="_4">基础题（理解概念）</h3>
<p><strong>练习 4.1</strong>：DDS Domain 概念理解</p>
<div class="codehilite"><pre><span></span><code>某机器人系统有 3 个节点：传感器节点、处理节点和控制节点。
如果传感器节点在 Domain 0，处理节点在 Domain 1，控制节点在 Domain 0，
请问哪些节点可以直接通信？为什么？
</code></pre></div>

<details>
<summary>答案</summary>
<p>只有传感器节点和控制节点可以直接通信，因为它们在同一个 Domain (0)。
处理节点在 Domain 1，无法与其他两个节点通信。
DDS 的 Domain 提供了通信隔离机制，不同 Domain 的节点无法相互发现和通信。</p>
<p>要解决这个问题，可以：</p>
<ol>
<li>将所有节点配置到同一个 Domain</li>
<li>使用 Domain Bridge 连接不同 Domain</li>
</ol>
</details>
<p><strong>练习 4.2</strong>：QoS 兼容性判断</p>
<div class="codehilite"><pre><span></span><code>发布者配置：Reliability=RELIABLE, Durability=TRANSIENT_LOCAL
订阅者配置：Reliability=BEST_EFFORT, Durability=VOLATILE

这两个端点能否建立通信？如果不能，如何修改？
</code></pre></div>

<details>
<summary>答案</summary>
<p>不能建立通信。原因：</p>
<ul>
<li>Reliability 不兼容：BEST_EFFORT 订阅者无法连接 RELIABLE 发布者</li>
<li>Durability 兼容：VOLATILE 订阅者可以连接 TRANSIENT_LOCAL 发布者</li>
</ul>
<p>修改方案：</p>
<ol>
<li>将订阅者的 Reliability 改为 RELIABLE</li>
<li>或将发布者的 Reliability 改为 BEST_EFFORT</li>
</ol>
</details>
<p><strong>练习 4.3</strong>：实时性分析</p>
<div class="codehilite"><pre><span></span><code>某控制系统要求 10ms 的控制周期，测量得到：

- 传感器采样：1ms
- DDS 通信：2ms（平均），4ms（最坏情况）
- 数据处理：3ms
- 执行器响应：2ms

该系统能否满足硬实时要求？软实时要求？
</code></pre></div>

<details>
<summary>答案</summary>
<p>平均情况：1 + 2 + 3 + 2 = 8ms &lt; 10ms ✓
最坏情况：1 + 4 + 3 + 2 = 10ms = 10ms（临界）</p>
<ul>
<li>硬实时：不能保证，因为最坏情况刚好达到截止时间，任何额外延迟都会违反约束</li>
<li>软实时：可以满足，平均情况下有 2ms 余量</li>
</ul>
<p>改进建议：</p>
<ol>
<li>优化 DDS 配置减少通信延迟</li>
<li>使用共享内存通信</li>
<li>提高控制周期到 12ms</li>
</ol>
</details>
<h3 id="_5">挑战题（深入思考）</h3>
<p><strong>练习 4.4</strong>：DDS 发现机制优化</p>
<div class="codehilite"><pre><span></span><code>某大规模机器人系统有 100 个节点，启动时出现&quot;发现风暴&quot;导致网络拥塞。
请设计一个分阶段启动策略，并给出 DDS 配置建议。
</code></pre></div>

<p><strong>提示</strong>：考虑 SPDP/SEDP 的周期、多播配置、启动延迟</p>
<details>
<summary>答案</summary>
<p>分阶段启动策略：</p>
<ol>
<li>按优先级分组：核心节点 → 感知节点 → 规划节点 → 执行节点</li>
<li>每组间隔 2-3 秒启动</li>
<li>组内节点随机延迟 0-500ms</li>
</ol>
<p>DDS 配置优化：</p>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;discovery&gt;</span>
<span class="w">  </span><span class="cm">&lt;!-- 降低发现频率 --&gt;</span>
<span class="w">  </span><span class="nt">&lt;participant_liveliness_lease_duration&gt;</span>30s<span class="nt">&lt;/participant_liveliness_lease_duration&gt;</span>
<span class="w">  </span><span class="nt">&lt;participant_liveliness_assert_period&gt;</span>10s<span class="nt">&lt;/participant_liveliness_assert_period&gt;</span>

<span class="w">  </span><span class="cm">&lt;!-- 使用单播初始对等点 --&gt;</span>
<span class="w">  </span><span class="nt">&lt;initial_peers&gt;</span>
<span class="w">    </span><span class="nt">&lt;element&gt;</span>192.168.1.100<span class="nt">&lt;/element&gt;</span>
<span class="w">    </span><span class="nt">&lt;element&gt;</span>192.168.1.101<span class="nt">&lt;/element&gt;</span>
<span class="w">  </span><span class="nt">&lt;/initial_peers&gt;</span>

<span class="w">  </span><span class="cm">&lt;!-- 限制多播 TTL --&gt;</span>
<span class="w">  </span><span class="nt">&lt;multicast_ttl&gt;</span>1<span class="nt">&lt;/multicast_ttl&gt;</span>
<span class="nt">&lt;/discovery&gt;</span>
</code></pre></div>

<p>额外优化：</p>
<ul>
<li>使用静态发现（预配置端点）</li>
<li>配置 Discovery Server 模式</li>
<li>实现自定义发现协议</li>
</ul>
</details>
<p><strong>练习 4.5</strong>：零拷贝通信设计</p>
<div class="codehilite"><pre><span></span><code>设计一个点云处理管道，从激光雷达接收数据（10Hz, 每帧 2MB），
经过滤波、分割、特征提取三个处理步骤，最终发送给规划模块。
如何设计才能实现零拷贝？
</code></pre></div>

<p><strong>提示</strong>：考虑共享内存、LoanedMessage、内存池</p>
<details>
<summary>答案</summary>
<p>零拷贝设计方案：</p>
<ol>
<li><strong>统一内存池</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PointCloudPool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">PointCloud</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pool_</span><span class="p">;</span><span class="w">  </span><span class="c1">// 2秒缓冲</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="w"> </span><span class="n">used_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">PointCloud</span><span class="o">*</span><span class="w"> </span><span class="n">allocate</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">deallocate</span><span class="p">(</span><span class="n">PointCloud</span><span class="o">*</span><span class="w"> </span><span class="n">pc</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<ol start="2">
<li><strong>使用 LoanedMessage</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 激光雷达节点</span>
<span class="k">auto</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">publisher_</span><span class="o">-&gt;</span><span class="n">borrow_loaned_message</span><span class="p">();</span>
<span class="n">lidar_driver_</span><span class="o">-&gt;</span><span class="n">read_into</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">data</span><span class="p">);</span>
<span class="n">publisher_</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>

<span class="c1">// 处理节点（原地处理）</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">callback</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PointCloud</span><span class="o">::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 直接修改共享内存中的数据</span>
<span class="w">    </span><span class="n">filter_inplace</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="n">segmentation_inplace</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 转发同一块内存</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">loaned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_pub_</span><span class="o">-&gt;</span><span class="n">borrow_loaned_message</span><span class="p">();</span>
<span class="w">    </span><span class="n">loaned</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">;</span><span class="w">  </span><span class="c1">// 仅复制元数据</span>
<span class="w">    </span><span class="n">next_pub_</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">loaned</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<ol start="3">
<li><strong>DDS 配置</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;transport&gt;</span>
<span class="w">  </span><span class="nt">&lt;use_shared_memory&gt;</span>true<span class="nt">&lt;/use_shared_memory&gt;</span>
<span class="w">  </span><span class="nt">&lt;shared_memory_segment_size&gt;</span>100MB<span class="nt">&lt;/shared_memory_segment_size&gt;</span>
<span class="nt">&lt;/transport&gt;</span>
</code></pre></div>

<p>性能收益：</p>
<ul>
<li>避免 2MB × 4 次 = 8MB 拷贝</li>
<li>降低内存带宽使用 75%</li>
<li>减少缓存污染</li>
</ul>
</details>
<p><strong>练习 4.6</strong>：跨域通信安全设计</p>
<div class="codehilite"><pre><span></span><code>设计一个工厂机器人系统，包含：

- 生产线机器人（Domain 10，高安全要求）
- 监控系统（Domain 20，中等安全）
- 访客演示系统（Domain 30，低安全）

如何设计 DDS Security 配置，实现分级安全访问？
</code></pre></div>

<p><strong>提示</strong>：考虑 Domain Bridge、访问控制、加密级别</p>
<details>
<summary>答案</summary>
<p>分级安全架构：</p>
<ol>
<li><strong>Domain 隔离策略</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="cm">&lt;!-- Domain 10: 生产线（最高安全） --&gt;</span>
<span class="nt">&lt;domain_rule&gt;</span>
<span class="w">  </span><span class="nt">&lt;domains&gt;&lt;id&gt;</span>10<span class="nt">&lt;/id&gt;&lt;/domains&gt;</span>
<span class="w">  </span><span class="nt">&lt;allow_unauthenticated_participants&gt;</span>false<span class="nt">&lt;/allow_unauthenticated_participants&gt;</span>
<span class="w">  </span><span class="nt">&lt;rtps_protection_kind&gt;</span>ENCRYPT<span class="nt">&lt;/rtps_protection_kind&gt;</span>
<span class="w">  </span><span class="nt">&lt;discovery_protection_kind&gt;</span>ENCRYPT<span class="nt">&lt;/discovery_protection_kind&gt;</span>
<span class="nt">&lt;/domain_rule&gt;</span>

<span class="cm">&lt;!-- Domain 20: 监控（中等安全） --&gt;</span>
<span class="nt">&lt;domain_rule&gt;</span>
<span class="w">  </span><span class="nt">&lt;domains&gt;&lt;id&gt;</span>20<span class="nt">&lt;/id&gt;&lt;/domains&gt;</span>
<span class="w">  </span><span class="nt">&lt;allow_unauthenticated_participants&gt;</span>false<span class="nt">&lt;/allow_unauthenticated_participants&gt;</span>
<span class="w">  </span><span class="nt">&lt;rtps_protection_kind&gt;</span>SIGN<span class="nt">&lt;/rtps_protection_kind&gt;</span>
<span class="w">  </span><span class="nt">&lt;discovery_protection_kind&gt;</span>SIGN<span class="nt">&lt;/discovery_protection_kind&gt;</span>
<span class="nt">&lt;/domain_rule&gt;</span>

<span class="cm">&lt;!-- Domain 30: 演示（基础安全） --&gt;</span>
<span class="nt">&lt;domain_rule&gt;</span>
<span class="w">  </span><span class="nt">&lt;domains&gt;&lt;id&gt;</span>30<span class="nt">&lt;/id&gt;&lt;/domains&gt;</span>
<span class="w">  </span><span class="nt">&lt;allow_unauthenticated_participants&gt;</span>true<span class="nt">&lt;/allow_unauthenticated_participants&gt;</span>
<span class="w">  </span><span class="nt">&lt;rtps_protection_kind&gt;</span>NONE<span class="nt">&lt;/rtps_protection_kind&gt;</span>
<span class="nt">&lt;/domain_rule&gt;</span>
</code></pre></div>

<ol start="2">
<li><strong>Domain Bridge 配置</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SecureDomainBridge</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 10 → 20: 只允许状态信息</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bridge_10_to_20</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">filter_topics</span><span class="p">({</span><span class="s">&quot;/robot/status&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;/production/metrics&quot;</span><span class="p">});</span>
<span class="w">        </span><span class="n">downsample_rate</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// 降低频率</span>
<span class="w">        </span><span class="n">remove_sensitive_fields</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 20 → 30: 只允许汇总数据</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bridge_20_to_30</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">aggregate_data</span><span class="p">();</span>
<span class="w">        </span><span class="n">anonymize_information</span><span class="p">();</span>
<span class="w">        </span><span class="n">rate_limit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 1Hz</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 30 → 10/20: 禁止</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bridge_30_to_others</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 单向隔离，不允许回传</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<ol start="3">
<li><strong>访问控制矩阵</strong>：</li>
</ol>
<p>| Source\Target | Domain 10 | Domain 20 | Domain 30 |</p>
<table>
<thead>
<tr>
<th>Source\Target</th>
<th>Domain 10</th>
<th>Domain 20</th>
<th>Domain 30</th>
</tr>
</thead>
<tbody>
<tr>
<td>Domain 10</td>
<td>Full</td>
<td>Status Only</td>
<td>None</td>
</tr>
<tr>
<td>Domain 20</td>
<td>Commands</td>
<td>Full</td>
<td>Summary</td>
</tr>
<tr>
<td>Domain 30</td>
<td>None</td>
<td>None</td>
<td>Full</td>
</tr>
</tbody>
</table>
<p>实现要点：</p>
<ul>
<li>使用不同的 CA 证书链</li>
<li>定期轮换密钥</li>
<li>审计所有跨域通信</li>
<li>实施最小权限原则</li>
</ul>
</details>
<p><strong>练习 4.7</strong>：实时性能分析与优化</p>
<div class="codehilite"><pre><span></span><code><span class="err">分析以下</span><span class="w"> </span><span class="n">ROS2</span><span class="w"> </span><span class="err">节点代码的实时性问题，并提出优化方案：</span>

<span class="k">class</span><span class="w"> </span><span class="n">DataProcessor</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">public</span><span class="w"> </span><span class="n">rclcpp</span><span class="p">::</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">callback</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sensor_msgs</span><span class="p">::</span><span class="n">msg</span><span class="p">::</span><span class="n">PointCloud2</span><span class="p">::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="err">问题代码</span>
<span class="w">        </span><span class="n">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ProcessedData</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="n">result</span><span class="o">-&gt;</span><span class="n">points</span><span class="o">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extract_point</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">z</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">threshold_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">result</span><span class="o">-&gt;</span><span class="n">points</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">std</span><span class="p">::</span><span class="n">sort</span><span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">points</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">result</span><span class="o">-&gt;</span><span class="n">points</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
<span class="w">        </span><span class="n">publisher_</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<details>
<summary>答案</summary>
<p>实时性问题：</p>
<ol>
<li>动态内存分配（make_shared, push_back）</li>
<li>不确定的排序时间（数据依赖）</li>
<li>潜在的内存重分配（vector 扩容）</li>
</ol>
<p>优化方案：</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">RTDataProcessor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// 预分配内存池</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">MAX_POINTS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_POINTS</span><span class="o">&gt;</span><span class="w"> </span><span class="n">point_buffer_</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">ProcessedData</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;</span><span class="w"> </span><span class="n">msg_pool_</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pool_index_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">callback</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sensor_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">PointCloud2</span><span class="o">::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 使用预分配的消息</span>
<span class="w">        </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msg_pool_</span><span class="p">[</span><span class="n">pool_index_</span><span class="p">];</span>
<span class="w">        </span><span class="n">pool_index_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pool_index_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">msg_pool_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// 使用固定大小缓冲区</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_POINTS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extract_point</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">threshold_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">point_buffer_</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 使用 O(n) 的部分排序代替完全排序</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">partial_sort</span><span class="p">(</span><span class="n">point_buffer_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span>
<span class="w">                         </span><span class="n">point_buffer_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">),</span>
<span class="w">                         </span><span class="n">point_buffer_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 使用 LoanedMessage</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">loaned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">publisher_</span><span class="o">-&gt;</span><span class="n">borrow_loaned_message</span><span class="p">();</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">copy_n</span><span class="p">(</span><span class="n">point_buffer_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span>
<span class="w">                   </span><span class="n">loaned</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">points</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
<span class="w">        </span><span class="n">publisher_</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">loaned</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>额外优化：</p>
<ol>
<li>使用 SIMD 指令加速点提取</li>
<li>实现无锁环形缓冲区</li>
<li>绑定 CPU 核心避免迁移</li>
<li>设置实时优先级</li>
</ol>
</details>
<p><strong>练习 4.8</strong>：分布式系统时钟同步</p>
<div class="codehilite"><pre><span></span><code>设计一个分布式机器人系统的时钟同步方案，要求：

- 5 个计算节点，通过千兆以太网连接
- 同步精度 &lt; 100μs
- 支持节点动态加入/退出
- 容忍单点故障
</code></pre></div>

<details>
<summary>答案</summary>
<p>时钟同步方案设计：</p>
<ol>
<li><strong>主从结合的 PTP 架构</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">HybridTimeSync</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">Role</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MASTER</span><span class="p">,</span><span class="w"> </span><span class="n">SLAVE</span><span class="p">,</span><span class="w"> </span><span class="n">CANDIDATE</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">Role</span><span class="w"> </span><span class="n">current_role_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">initialize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 选举主时钟</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_best_clock</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">current_role_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MASTER</span><span class="p">;</span>
<span class="w">            </span><span class="n">start_ptp_master</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">current_role_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SLAVE</span><span class="p">;</span>
<span class="w">            </span><span class="n">start_ptp_slave</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 启动备份机制</span>
<span class="w">        </span><span class="n">start_backup_protocol</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">start_backup_protocol</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 使用 Raft 协议选举备用主时钟</span>
<span class="w">        </span><span class="n">raft_node_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RaftNode</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="n">raft_node_</span><span class="o">-&gt;</span><span class="n">on_leader_change</span><span class="p">([</span><span class="k">this</span><span class="p">](</span><span class="n">NodeId</span><span class="w"> </span><span class="n">leader</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">leader</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">self_id_</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">current_role_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CANDIDATE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">promote_to_master</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<ol start="2">
<li><strong>硬件时间戳支持</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 启用网卡硬件时间戳</span>
ethtool<span class="w"> </span>-T<span class="w"> </span>eth0
ethtool<span class="w"> </span>-K<span class="w"> </span>eth0<span class="w"> </span>rx-all<span class="w"> </span>on
ethtool<span class="w"> </span>-K<span class="w"> </span>eth0<span class="w"> </span>tx-timestamp-all<span class="w"> </span>on
</code></pre></div>

<ol start="3">
<li><strong>DDS 时间 QoS 配置</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TimeSyncedNode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">configure_time_qos</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 使用 DDS 时间戳</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">qos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">QoS</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">reliability</span><span class="p">(</span><span class="n">RMW_QOS_POLICY_RELIABILITY_RELIABLE</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">deadline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>

<span class="w">        </span><span class="c1">// 启用源时间戳</span>
<span class="w">        </span><span class="n">publisher_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_publisher</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">qos</span><span class="p">);</span>
<span class="w">        </span><span class="n">publisher_</span><span class="o">-&gt;</span><span class="n">set_source_timestamp</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">publish_with_hw_timestamp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Message</span><span class="o">&amp;</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 获取硬件时间戳</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">timespec</span><span class="w"> </span><span class="n">hw_time</span><span class="p">;</span>
<span class="w">        </span><span class="n">ioctl</span><span class="p">(</span><span class="n">socket_fd_</span><span class="p">,</span><span class="w"> </span><span class="n">SIOCGSTAMPNS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hw_time</span><span class="p">);</span>

<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">stamped_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msg</span><span class="p">;</span>
<span class="w">        </span><span class="n">stamped_msg</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">stamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convert_to_ros_time</span><span class="p">(</span><span class="n">hw_time</span><span class="p">);</span>
<span class="w">        </span><span class="n">publisher_</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">stamped_msg</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<ol start="4">
<li><strong>容错机制</strong>：
- 主时钟故障检测（心跳超时）
- 自动切换到备用主时钟
- 时间跳变检测和平滑</li>
</ol>
<p>预期性能：</p>
<ul>
<li>同步精度：50-80μs（千兆网）</li>
<li>收敛时间：&lt; 30s</li>
<li>故障切换：&lt; 5s</li>
</ul>
</details>
<h2 id="49">4.9 常见陷阱与错误</h2>
<h3 id="491-dds">4.9.1 DDS 配置错误</h3>
<p><strong>问题 1：Domain ID 冲突</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 错误：多个独立系统使用相同 Domain ID</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">ROS_DOMAIN_ID</span><span class="o">=</span><span class="m">0</span><span class="w">  </span><span class="c1"># 默认值，容易冲突</span>
</code></pre></div>

<p><strong>解决方案</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 使用唯一的 Domain ID（0-232）</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">ROS_DOMAIN_ID</span><span class="o">=</span><span class="m">42</span><span class="w">  </span><span class="c1"># 项目专用</span>
<span class="c1"># 或基于用户 ID 生成</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">ROS_DOMAIN_ID</span><span class="o">=</span><span class="k">$(</span>id<span class="w"> </span>-u<span class="k">)</span>
</code></pre></div>

<p><strong>问题 2：发现机制失效</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：在 Docker 容器中多播不工作</span>
<span class="c1">// 症状：节点无法相互发现</span>
</code></pre></div>

<p><strong>解决方案</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 使用主机网络模式</span>
docker<span class="w"> </span>run<span class="w"> </span>--network<span class="w"> </span>host<span class="w"> </span>my_ros2_image

<span class="c1"># 或配置共享内存通信</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">RMW_IMPLEMENTATION</span><span class="o">=</span>rmw_cyclonedds_cpp
<span class="nb">export</span><span class="w"> </span><span class="nv">CYCLONEDDS_URI</span><span class="o">=</span><span class="s1">&#39;&lt;CycloneDDS&gt;&lt;Domain&gt;&lt;General&gt;&lt;Transport&gt;shmem&lt;/Transport&gt;&lt;/General&gt;&lt;/Domain&gt;&lt;/CycloneDDS&gt;&#39;</span>
</code></pre></div>

<h3 id="492-qos">4.9.2 QoS 不匹配问题</h3>
<p><strong>问题：传感器数据丢失</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：使用默认 QoS 订阅传感器数据</span>
<span class="k">auto</span><span class="w"> </span><span class="n">sub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_subscription</span><span class="o">&lt;</span><span class="n">sensor_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Image</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;/camera/image&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">  </span><span class="c1">// 默认 RELIABLE</span>
<span class="w">    </span><span class="n">callback</span><span class="p">);</span>
</code></pre></div>

<p><strong>正确做法</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使用传感器数据 QoS 配置文件</span>
<span class="k">auto</span><span class="w"> </span><span class="n">sub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_subscription</span><span class="o">&lt;</span><span class="n">sensor_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Image</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;/camera/image&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">SensorDataQoS</span><span class="p">(),</span><span class="w">  </span><span class="c1">// BEST_EFFORT</span>
<span class="w">    </span><span class="n">callback</span><span class="p">);</span>
</code></pre></div>

<h3 id="493">4.9.3 实时性破坏</h3>
<p><strong>问题：回调中的动态内存分配</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：破坏实时性</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">callback</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Message</span><span class="o">::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="n">points</span><span class="p">;</span><span class="w">  </span><span class="c1">// 动态分配</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">filter</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w">  </span><span class="c1">// 可能触发重分配</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>正确做法</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 预分配内存</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RTNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_POINTS</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer_</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">callback</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Message</span><span class="o">::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">filter</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_POINTS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">buffer_</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="494">4.9.4 生命周期管理错误</h3>
<p><strong>问题：未正确处理生命周期转换</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：在 on_configure 中启动定时器</span>
<span class="n">CallbackReturn</span><span class="w"> </span><span class="nf">on_configure</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">timer_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_wall_timer</span><span class="p">(</span><span class="mi">1</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">);</span><span class="w">  </span><span class="c1">// 错误！</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CallbackReturn</span><span class="o">::</span><span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>正确做法</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="n">CallbackReturn</span><span class="w"> </span><span class="nf">on_configure</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 只创建，不启动</span>
<span class="w">    </span><span class="n">timer_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_wall_timer</span><span class="p">(</span><span class="mi">1</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">);</span>
<span class="w">    </span><span class="n">timer_</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">();</span><span class="w">  </span><span class="c1">// 立即取消</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CallbackReturn</span><span class="o">::</span><span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">CallbackReturn</span><span class="w"> </span><span class="nf">on_activate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">timer_</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span><span class="w">  </span><span class="c1">// 在激活时启动</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CallbackReturn</span><span class="o">::</span><span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="495">4.9.5 参数竞态条件</h3>
<p><strong>问题：参数更新导致的数据竞争</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 危险：多线程访问参数</span>
<span class="k">class</span><span class="w"> </span><span class="nc">UnsafeNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">speed_</span><span class="p">;</span><span class="w">  </span><span class="c1">// 共享变量</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">param_callback</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Parameter</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">speed_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">as_double</span><span class="p">();</span><span class="w">  </span><span class="c1">// 写入</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">control_callback</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">speed_</span><span class="p">;</span><span class="w">  </span><span class="c1">// 读取，可能不一致</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>正确做法</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SafeNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">speed_</span><span class="p">;</span><span class="w">  </span><span class="c1">// 原子操作</span>
<span class="w">    </span><span class="c1">// 或使用互斥锁</span>
<span class="w">    </span><span class="k">mutable</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="w"> </span><span class="n">speed_mutex_</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">param_callback</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Parameter</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">speed_mutex_</span><span class="p">);</span>
<span class="w">        </span><span class="n">speed_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">as_double</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">control_callback</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">speed_mutex_</span><span class="p">);</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">speed_</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="496-dds">4.9.6 DDS 资源泄漏</h3>
<p><strong>问题：未正确清理 DDS 资源</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：动态创建发布者但未清理</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">process_data</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">pub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">create_publisher</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;temp_topic&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">pub</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// pub 超出作用域，但 DDS 资源可能未释放</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>正确做法</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 重用发布者或显式管理生命周期</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PublisherManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Publisher</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;::</span><span class="n">SharedPtr</span><span class="o">&gt;</span><span class="w"> </span><span class="n">publishers_</span><span class="p">;</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">get_or_create_publisher</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">topic</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">publishers_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">topic</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">publishers_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">publishers_</span><span class="p">[</span><span class="n">topic</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">create_publisher</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">publishers_</span><span class="p">[</span><span class="n">topic</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2 id="410">4.10 最佳实践检查清单</h2>
<h3 id="4101">4.10.1 架构设计审查</h3>
<ul>
<li>[ ] <strong>DDS 实现选择</strong></li>
<li>评估了不同 DDS 实现的性能特性</li>
<li>选择符合项目需求（实时性/资源/许可证）</li>
<li>
<p>配置了合适的 Domain ID</p>
</li>
<li>
<p>[ ] <strong>节点设计</strong></p>
</li>
<li>合理划分节点粒度（单一职责）</li>
<li>使用生命周期节点管理复杂状态</li>
<li>
<p>实现了优雅的错误处理和恢复</p>
</li>
<li>
<p>[ ] <strong>通信架构</strong></p>
</li>
<li>选择了合适的通信模式（话题/服务/动作）</li>
<li>配置了适当的 QoS 策略</li>
<li>考虑了带宽和延迟需求</li>
</ul>
<h3 id="4102">4.10.2 实时性能检查</h3>
<ul>
<li>[ ] <strong>内存管理</strong></li>
<li>预分配所有必要的内存</li>
<li>避免在关键路径上动态分配</li>
<li>
<p>使用内存池管理动态需求</p>
</li>
<li>
<p>[ ] <strong>执行器配置</strong></p>
</li>
<li>选择了合适的执行器类型</li>
<li>配置了线程优先级和 CPU 亲和性</li>
<li>
<p>实现了确定性的调度策略</p>
</li>
<li>
<p>[ ] <strong>时间约束</strong></p>
</li>
<li>定义了明确的截止时间要求</li>
<li>测量并验证了最坏情况执行时间</li>
<li>实现了超时检测和处理</li>
</ul>
<h3 id="4103-qos">4.10.3 QoS 配置检查</h3>
<ul>
<li>[ ] <strong>可靠性设置</strong></li>
<li>传感器数据使用 BEST_EFFORT</li>
<li>控制命令使用 RELIABLE</li>
<li>
<p>配置了合适的队列深度</p>
</li>
<li>
<p>[ ] <strong>历史和持久性</strong></p>
</li>
<li>Late-joining 节点考虑 TRANSIENT_LOCAL</li>
<li>配置了合适的历史深度</li>
<li>
<p>避免 KEEP_ALL 导致内存溢出</p>
</li>
<li>
<p>[ ] <strong>时间相关 QoS</strong></p>
</li>
<li>设置了合理的 Deadline</li>
<li>配置了消息 Lifespan</li>
<li>实现了 QoS 事件处理</li>
</ul>
<h3 id="4104">4.10.4 安全性审查</h3>
<ul>
<li>[ ] <strong>认证与授权</strong></li>
<li>启用了 SROS2（如需要）</li>
<li>配置了适当的访问控制</li>
<li>
<p>实现了密钥管理策略</p>
</li>
<li>
<p>[ ] <strong>网络安全</strong></p>
</li>
<li>限制了网络接口绑定</li>
<li>配置了防火墙规则</li>
<li>
<p>启用了加密通信（如需要）</p>
</li>
<li>
<p>[ ] <strong>数据保护</strong></p>
</li>
<li>敏感数据已加密</li>
<li>实现了数据完整性检查</li>
<li>配置了审计日志</li>
</ul>
<h3 id="4105">4.10.5 部署与运维</h3>
<ul>
<li>[ ] <strong>配置管理</strong></li>
<li>使用配置文件而非硬编码</li>
<li>实现了参数验证</li>
<li>
<p>支持运行时重配置</p>
</li>
<li>
<p>[ ] <strong>监控与诊断</strong></p>
</li>
<li>实现了健康检查接口</li>
<li>配置了性能指标收集</li>
<li>
<p>提供了调试和故障排查工具</p>
</li>
<li>
<p>[ ] <strong>容错机制</strong></p>
</li>
<li>实现了故障检测</li>
<li>设计了降级运行模式</li>
<li>测试了故障恢复流程</li>
</ul>
<h3 id="4106">4.10.6 性能优化</h3>
<ul>
<li>[ ] <strong>通信优化</strong></li>
<li>启用了共享内存（本地通信）</li>
<li>使用了零拷贝 API（大消息）</li>
<li>
<p>优化了消息大小和频率</p>
</li>
<li>
<p>[ ] <strong>计算优化</strong></p>
</li>
<li>识别并优化了热点代码</li>
<li>使用了 SIMD/并行计算</li>
<li>
<p>实现了缓存友好的数据结构</p>
</li>
<li>
<p>[ ] <strong>资源使用</strong></p>
</li>
<li>监控了 CPU 和内存使用</li>
<li>优化了 DDS 缓冲区大小</li>
<li>控制了线程和文件描述符数量</li>
</ul>
<h3 id="4107">4.10.7 测试验证</h3>
<ul>
<li>[ ] <strong>功能测试</strong></li>
<li>单元测试覆盖核心逻辑</li>
<li>集成测试验证节点交互</li>
<li>
<p>系统测试验证端到端功能</p>
</li>
<li>
<p>[ ] <strong>性能测试</strong></p>
</li>
<li>基准测试关键操作</li>
<li>负载测试系统容量</li>
<li>
<p>延迟测试通信性能</p>
</li>
<li>
<p>[ ] <strong>鲁棒性测试</strong></p>
</li>
<li>故障注入测试</li>
<li>网络异常测试</li>
<li>资源耗尽测试</li>
</ul>
<hr />
<p>通过遵循这份检查清单，可以确保 ROS2 系统的架构设计合理、性能优良、运行可靠。记住，最佳实践需要根据具体项目需求进行调整，这份清单提供了一个全面的起点。</p>
            </article>
            
            <nav class="page-nav"><a href="chapter3.html" class="nav-link prev">← 第 3 章：从 ROS1 到 ROS2 的迁移策略</a><a href="chapter5.html" class="nav-link next">第 5 章：节点与执行器模型 →</a></nav>
        </main>
    </div>
</body>
</html>