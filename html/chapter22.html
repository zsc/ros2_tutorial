<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第 22 章：神经网络运动控制</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">ROS2 完全教程：从原理到实践</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 1 章：ROS1 核心概念回顾</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 2 章：ROS1 的局限性分析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 3 章：从 ROS1 到 ROS2 的迁移策略</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 4 章：ROS2 架构与设计理念</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 5 章：节点与执行器模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 6 章：通信机制深度解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 7 章：Launch 系统与配置管理</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 8 章：tf2 坐标变换框架</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 9 章：时间同步与回放系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 10 章：传感器数据处理管道</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 11 章：SLAM 与定位系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 12 章：导航栈 Nav2</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 13 章：ros2_control 框架</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 14 章：MoveIt2 运动规划</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 15 章：实时系统与性能优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 16 章：安全性与诊断系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 17 章：仿真集成（Gazebo/Ignition）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 18 章：多机器人系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 19 章：计算机视觉与深度学习</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 20 章：机器人强化学习</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter21.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 21 章：大语言模型与具身智能</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter22.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 22 章：神经网络运动控制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="22">第 22 章：神经网络运动控制</h1>
<h2 id="_1">章节大纲</h2>
<h3 id="1">1. 模仿学习与示教学习</h3>
<ul>
<li>1.1 行为克隆（Behavioral Cloning）基础</li>
<li>1.2 数据集收集与增强策略</li>
<li>1.3 分布偏移问题与解决方案</li>
<li>1.4 ROS2 中的示教数据管道</li>
</ul>
<h3 id="2-diffusion-policy">2. 扩散模型（Diffusion Policy）</h3>
<ul>
<li>2.1 扩散模型在机器人控制中的应用</li>
<li>2.2 条件生成与轨迹预测</li>
<li>2.3 实时推理优化</li>
<li>2.4 与传统规划器的对比</li>
</ul>
<h3 id="3-mpc">3. 神经网络 MPC</h3>
<ul>
<li>3.1 学习动力学模型</li>
<li>3.2 可微分MPC框架</li>
<li>3.3 约束处理与安全保证</li>
<li>3.4 在线学习与自适应</li>
</ul>
<h3 id="4">4. 力矩控制与柔顺控制</h3>
<ul>
<li>4.1 阻抗控制神经网络</li>
<li>4.2 接触丰富任务的学习</li>
<li>4.3 力/位混合控制</li>
<li>4.4 安全性与稳定性分析</li>
</ul>
<h3 id="5-toyota-research">5. 产业案例研究：Toyota Research 柔性装配</h3>
<h3 id="6-act">6. 高级话题：ACT 与端到端模仿学习</h3>
<h3 id="7">7. 本章小结</h3>
<h3 id="8">8. 练习题</h3>
<h3 id="9">9. 常见陷阱与错误</h3>
<h3 id="10">10. 最佳实践检查清单</h3>
<hr />
<h2 id="_2">开篇介绍</h2>
<p>神经网络运动控制代表了机器人学习领域的前沿方向，它将深度学习的强大表征能力与机器人运动控制的实时性要求相结合。本章将深入探讨如何在 ROS2 环境中实现和部署基于神经网络的运动控制系统，涵盖从模仿学习到扩散模型的最新技术。</p>
<p>传统的机器人控制方法依赖于精确的数学模型和手工设计的控制器，而神经网络方法能够从数据中学习复杂的控制策略，处理高维状态空间，并适应未建模的动力学。这种范式转变为机器人系统带来了前所未有的灵活性和适应性，特别是在接触丰富的操作任务和复杂环境交互中。</p>
<p>本章的学习目标包括：</p>
<ul>
<li>掌握模仿学习的核心技术和实施方法</li>
<li>理解扩散模型在机器人控制中的应用</li>
<li>实现神经网络增强的模型预测控制</li>
<li>设计安全可靠的力控制学习系统</li>
<li>部署端到端的神经网络控制器到实际机器人</li>
</ul>
<h2 id="1_1">1. 模仿学习与示教学习</h2>
<h3 id="11-behavioral-cloning">1.1 行为克隆（Behavioral Cloning）基础</h3>
<p>模仿学习是让机器人通过观察专家演示来学习控制策略的方法。在 ROS2 环境中，这涉及到数据收集、模型训练和实时部署的完整流程。</p>
<p><strong>核心概念</strong></p>
<p>行为克隆将控制问题转化为监督学习问题：</p>
<p>$$\pi_\theta^* = \arg\min_\theta \mathbb{E}_{(s,a) \sim \mathcal{D}_\text{expert}} \left[ \mathcal{L}(\pi_\theta(s), a) \right]$$
其中 $\pi_\theta$ 是参数化的策略网络，$\mathcal{D}_\text{expert}$ 是专家演示数据集，$\mathcal{L}$ 是损失函数（通常是 MSE 或交叉熵）。</p>
<p><strong>ROS2 实现架构</strong></p>
<div class="codehilite"><pre><span></span><code>┌─────────────────┐     ┌──────────────┐     ┌─────────────┐
│ Teleoperation   │────▶│ Data Logger  │────▶│ Training    │
│ Node            │     │ Node         │     │ Pipeline    │
└─────────────────┘     └──────────────┘     └─────────────┘
         │                      │                     │
         │                      ▼                     ▼
         │              ┌──────────────┐     ┌─────────────┐
         └─────────────▶│ Rosbag2      │     │ Neural      │
                        │ Recording    │     │ Policy Node │
                        └──────────────┘     └─────────────┘
</code></pre></div>

<h3 id="12">1.2 数据集收集与增强策略</h3>
<p>高质量的演示数据是成功的关键。ROS2 提供了强大的数据收集工具链：</p>
<p><strong>多模态数据同步</strong></p>
<p>在收集演示数据时，需要同步多种传感器输入：</p>
<ul>
<li>关节状态 (sensor_msgs/JointState)</li>
<li>力/扭矩传感器 (geometry_msgs/WrenchStamped)  </li>
<li>视觉输入 (sensor_msgs/Image, sensor_msgs/PointCloud2)</li>
<li>触觉反馈 (自定义消息类型)</li>
</ul>
<p>时间同步使用 ROS2 的 message_filters：</p>
<div class="codehilite"><pre><span></span><code>┌──────────┐  ┌──────────┐  ┌──────────┐
│ Camera   │  │ Force    │  │ Joint    │
│ 30 Hz    │  │ 1000 Hz  │  │ 500 Hz   │
└────┬─────┘  └────┬─────┘  └────┬─────┘
     │             │             │
     ▼             ▼             ▼
┌─────────────────────────────────────┐
│     TimeSynchronizer (ApproxTime)    │
│         Sync tolerance: 10ms         │
└─────────────────┬───────────────────┘
                  ▼
         ┌──────────────┐
         │ Synchronized │
         │ Data Buffer  │
         └──────────────┘
</code></pre></div>

<p><strong>数据增强技术</strong></p>
<p>为了提高泛化能力，采用以下增强策略：</p>
<ol>
<li><strong>时间扰动</strong>：对动作序列添加时间抖动</li>
<li><strong>空间增强</strong>：对视觉输入进行几何变换</li>
<li><strong>噪声注入</strong>：模拟传感器噪声</li>
<li><strong>域随机化</strong>：变化环境参数
$$\tilde{a}_t = a_t + \epsilon_\text{time} + \mathcal{N}(0, \sigma^2)$$</li>
</ol>
<h3 id="13">1.3 分布偏移问题与解决方案</h3>
<p>行为克隆的主要挑战是协变量偏移（covariate shift）问题。当机器人执行学习到的策略时，小的误差会累积，导致状态分布偏离训练分布。</p>
<p><strong>DAgger (Dataset Aggregation) 算法</strong></p>
<p>DAgger 通过迭代收集数据来解决这个问题：</p>
<ol>
<li>初始化：使用初始专家数据训练策略 $\pi_0$</li>
<li>执行：运行当前策略 $\pi_i$ 收集状态</li>
<li>标注：专家为这些状态提供正确动作</li>
<li>聚合：将新数据加入数据集</li>
<li>重训练：更新策略 $\pi_{i+1}$</li>
</ol>
<p><strong>误差累积分析</strong></p>
<p>考虑 T 步的轨迹，误差累积为：
$$\text{Error}(T) \leq \epsilon_\text{single} \cdot \sum_{t=0}^{T-1} \beta^t$$
其中 $\epsilon_\text{single}$ 是单步预测误差，$\beta$ 是误差传播因子。</p>
<h3 id="14-ros2">1.4 ROS2 中的示教数据管道</h3>
<p>完整的数据管道包括收集、处理、训练和部署：</p>
<p><strong>数据收集节点设计</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DemonstrationCollector</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s1">&#39;demo_collector&#39;</span><span class="p">)</span>

        <span class="c1"># 订阅器</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">joint_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_subscription</span><span class="p">(</span>
            <span class="n">JointState</span><span class="p">,</span> <span class="s1">&#39;/joint_states&#39;</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">joint_callback</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_subscription</span><span class="p">(</span>
            <span class="n">Image</span><span class="p">,</span> <span class="s1">&#39;/camera/image&#39;</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">image_callback</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

        <span class="c1"># 数据缓冲区</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">DataBuffer</span><span class="p">(</span><span class="n">max_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

        <span class="c1"># 同步器</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sync</span> <span class="o">=</span> <span class="n">ApproximateTimeSynchronizer</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">joint_sub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_sub</span><span class="p">],</span>
            <span class="n">queue_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
            <span class="n">slop</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># 10ms 容差</span>
</code></pre></div>

<p><strong>在线学习与适应</strong></p>
<p>实时适应是神经网络控制的关键优势：</p>
<div class="codehilite"><pre><span></span><code>┌──────────────┐     ┌─────────────┐     ┌──────────────┐
│ Experience   │────▶│ Replay      │────▶│ Online       │
│ Buffer       │     │ Buffer      │     │ Training     │
└──────────────┘     └─────────────┘     └──────────────┘
        ▲                                        │
        │                                        ▼
┌──────────────┐                        ┌──────────────┐
│ Robot        │◀───────────────────────│ Policy       │
│ Execution    │                        │ Network      │
└──────────────┘                        └──────────────┘
</code></pre></div>

<h2 id="2-diffusion-policy_1">2. 扩散模型（Diffusion Policy）</h2>
<h3 id="21">2.1 扩散模型在机器人控制中的应用</h3>
<p>扩散模型通过逐步去噪过程生成高质量的动作序列，特别适合处理多模态分布和长期规划任务。</p>
<p><strong>前向扩散过程</strong></p>
<p>给定轨迹 $\tau_0$，前向过程逐步添加噪声：
$$q(\tau_t | \tau_{t-1}) = \mathcal{N}(\tau_t; \sqrt{1-\beta_t}\tau_{t-1}, \beta_t I)$$
经过 T 步后，$\tau_T \sim \mathcal{N}(0, I)$</p>
<p><strong>反向去噪过程</strong></p>
<p>学习反向过程来生成轨迹：
$$p_\theta(\tau_{t-1} | \tau_t, s) = \mathcal{N}(\tau_{t-1}; \mu_\theta(\tau_t, t, s), \Sigma_\theta(\tau_t, t, s))$$
其中 $s$ 是当前观测状态，作为条件输入。</p>
<p><strong>优势分析</strong></p>
<ol>
<li><strong>多模态建模</strong>：自然处理多个可行解</li>
<li><strong>长期规划</strong>：生成完整轨迹而非单步动作</li>
<li><strong>不确定性量化</strong>：通过多次采样评估不确定性</li>
</ol>
<h3 id="22_1">2.2 条件生成与轨迹预测</h3>
<p><strong>条件扩散架构</strong></p>
<div class="codehilite"><pre><span></span><code>State s ──────┐
              ▼
         ┌──────────┐
         │ Encoder  │
         └────┬─────┘
              │
Goal g ───────┼─────┐
              ▼     ▼
         ┌─────────────┐
         │ Cross       │
         │ Attention   │
         └──────┬──────┘
                │
Noisy τt ───────┼─────┐
                ▼     ▼
         ┌─────────────┐
         │ U-Net       │
         │ Denoiser    │
         └──────┬──────┘
                │
                ▼
           Predicted τ_{t-1}
</code></pre></div>

<p><strong>分类器引导（Classifier Guidance）</strong></p>
<p>通过添加梯度项增强条件生成：
$$\nabla_{\tau_t} \log p(\tau_{t-1}|\tau_t, s) = \nabla_{\tau_t} \log p(\tau_{t-1}|\tau_t) + \gamma \nabla_{\tau_t} \log p(s|\tau_t)$$</p>
<h3 id="23">2.3 实时推理优化</h3>
<p>扩散模型的主要挑战是推理速度。优化策略包括：</p>
<p><strong>DDIM 采样器</strong></p>
<p>确定性采样减少去噪步数：
$$\tau_{t-1} = \sqrt{\alpha_{t-1}} \left( \frac{\tau_t - \sqrt{1-\alpha_t} \epsilon_\theta(\tau_t, t)}{\sqrt{\alpha_t}} \right) + \sqrt{1-\alpha_{t-1}} \epsilon_\theta(\tau_t, t)$$
<strong>模型蒸馏</strong></p>
<p>将多步去噪过程蒸馏为少步模型：
$$\mathcal{L}_\text{distill} = \mathbb{E}_{\tau_0, t} \left[ ||\tau_\text{teacher}^{(N)} - \tau_\text{student}^{(1)}||^2 \right]$$
<strong>推理延迟分析</strong></p>
<p>| 方法 | 去噪步数 | 推理时间 | 控制频率 |</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>去噪步数</th>
<th>推理时间</th>
<th>控制频率</th>
</tr>
</thead>
<tbody>
<tr>
<td>DDPM</td>
<td>1000</td>
<td>2000ms</td>
<td>0.5 Hz</td>
</tr>
<tr>
<td>DDIM</td>
<td>50</td>
<td>100ms</td>
<td>10 Hz</td>
</tr>
<tr>
<td>蒸馏模型</td>
<td>1-4</td>
<td>5-20ms</td>
<td>50-200 Hz</td>
</tr>
</tbody>
</table>
<h3 id="24">2.4 与传统规划器的对比</h3>
<p><strong>性能对比表</strong></p>
<p>| 特性 | 扩散模型 | RRT* | 轨迹优化 |</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>扩散模型</th>
<th>RRT*</th>
<th>轨迹优化</th>
</tr>
</thead>
<tbody>
<tr>
<td>多模态处理</td>
<td>✓✓✓</td>
<td>✓</td>
<td>✗</td>
</tr>
<tr>
<td>计算复杂度</td>
<td>O(T·N)</td>
<td>O(n log n)</td>
<td>O(H²)</td>
</tr>
<tr>
<td>实时性</td>
<td>中等</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>泛化能力</td>
<td>高</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>约束处理</td>
<td>软约束</td>
<td>硬约束</td>
<td>硬约束</td>
</tr>
</tbody>
</table>
<h2 id="3-mpc_1">3. 神经网络 MPC</h2>
<h3 id="31">3.1 学习动力学模型</h3>
<p>神经网络 MPC 使用学习的动力学模型进行预测控制：</p>
<p><strong>动力学模型架构</strong>
$$s_{t+1} = f_\theta(s_t, a_t) + \epsilon$$
其中 $f_\theta$ 是神经网络，$\epsilon$ 是建模误差。</p>
<p><strong>集成模型（Ensemble）</strong></p>
<p>使用多个模型捕捉认知不确定性：
$$\bar{s}_{t+1} = \frac{1}{M} \sum_{i=1}^M f_{\theta_i}(s_t, a_t)$$</p>
<p>$$\text{Var}[s_{t+1}] = \frac{1}{M} \sum_{i=1}^M (f_{\theta_i}(s_t, a_t) - \bar{s}_{t+1})^2$$</p>
<h3 id="32-mpc">3.2 可微分MPC框架</h3>
<p><strong>优化问题表述</strong>
$$\min_{a_{0:H-1}} \sum_{t=0}^{H-1} L(s_t, a_t) + L_f(s_H)$$
subject to:
$$s_{t+1} = f_\theta(s_t, a_t)$$
$$a_t \in \mathcal{A}, s_t \in \mathcal{S}$$
<strong>梯度计算</strong></p>
<p>通过自动微分计算梯度：
$$\frac{\partial L}{\partial a_t} = \frac{\partial L}{\partial s_{t+1}} \cdot \frac{\partial f_\theta}{\partial a_t}$$</p>
            </article>
            
            <nav class="page-nav"><a href="chapter21.html" class="nav-link prev">← 第 21 章：大语言模型与具身智能</a><a href="CLAUDE.html" class="nav-link next">Untitled →</a></nav>
        </main>
    </div>
</body>
</html>